
<!DOCTYPE html>
<html lang="zh-CN" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Spring框架 - 勉~杌子生的博客</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="Fechin,"> 
    <meta name="description" content="1. Spring部分1. 谈谈你对spring框架的认识

Spring是一个轻量级Java开发框架

目的是为了解决企业级应用开发的业务逻辑层和其他各层的耦合问题。它是一个分层的JavaSE&amp;#,"> 
    <meta name="author" content="Fstoer BG"> 
    <link rel="alternative" href="atom.xml" title="勉~杌子生的博客" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
    
    
    <meta name="twitter:card" content="summary"/>
    <meta name="twitter:title" content="Spring框架 - 勉~杌子生的博客"/>
    <meta name="twitter:description" content="1. Spring部分1. 谈谈你对spring框架的认识

Spring是一个轻量级Java开发框架

目的是为了解决企业级应用开发的业务逻辑层和其他各层的耦合问题。它是一个分层的JavaSE&amp;#,"/>
    
    
    
    
    <meta property="og:site_name" content="勉~杌子生的博客"/>
    <meta property="og:type" content="object"/>
    <meta property="og:title" content="Spring框架 - 勉~杌子生的博客"/>
    <meta property="og:description" content="1. Spring部分1. 谈谈你对spring框架的认识

Spring是一个轻量级Java开发框架

目的是为了解决企业级应用开发的业务逻辑层和其他各层的耦合问题。它是一个分层的JavaSE&amp;#,"/>
    
<link rel="stylesheet" href="/css/diaspora.css">

    <script>window.searchDbPath = "/search.xml";</script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
<meta name="generator" content="Hexo 6.2.0"></head>

<body class="loading">
    <span id="config-title" style="display:none">勉~杌子生的博客</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="https://fstoer-1.github.io"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">Spring框架</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">Spring框架</h1>
        <div class="stuff">
            <span>八月 28, 2022</span>
            
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/Spring/" rel="tag">Spring</a></li></ul>


        </div>
        <div class="content markdown">
            <h1 id="1-Spring部分"><a href="#1-Spring部分" class="headerlink" title="1. Spring部分"></a>1. Spring部分</h1><h2 id="1-谈谈你对spring框架的认识"><a href="#1-谈谈你对spring框架的认识" class="headerlink" title="1. 谈谈你对spring框架的认识"></a>1. 谈谈你对spring框架的认识</h2><blockquote>
<ul>
<li><p>Spring是一个轻量级Java开发框架</p>
</li>
<li><p>目的是为了解决企业级应用开发的业务逻辑层和其他各层的耦合问题。它是一个分层的JavaSE&#x2F;JavaEE full-stack（一站式）轻量级开源框架，为开发Java应用程序提供全面的基础架构支持。Spring负责基础架构，因此Java开发者可以专注于应用程序的开发。</p>
</li>
<li><p>Spring最根本的使命是解决企业级应用开发的复杂性，即简化Java开发。</p>
</li>
<li><p><strong>Spring可以做很多事情，它为企业级开发提供给了丰富的功能，但是这些功能的底层都依赖于它的两个核心特性，也就是依赖注入（dependency injection，DI）和面向切面编程（aspect-oriented programming，AOP）</strong></p>
</li>
</ul>
</blockquote>
<h2 id="2-Spring框架优缺点"><a href="#2-Spring框架优缺点" class="headerlink" title="2. Spring框架优缺点"></a>2. Spring框架优缺点</h2><blockquote>
<h4>优点</h4>

<p><strong>①. 方便解耦，简化开发</strong></p>
<p>Spring就是一个大工厂，可以将所有对象的创建和依赖关系的维护，交给Spring管理。</p>
<p><strong>②. AOP编程的支持</strong></p>
<p>Spring提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能。</p>
<p><strong>③. 声明式事务的支持</strong></p>
<p>只需要通过配置就可以完成对事务的管理，而无需手动编程。</p>
<p><strong>④. 方便程序的测试</strong></p>
<p>Spring对Junit4支持，可以通过注解方便的测试Spring程序。</p>
<p><strong>⑤. 方便集成各种优秀框架</strong></p>
<p>Spring不排斥各种优秀的开源框架，其内部提供了对各种优秀框架的直接支持（如：Struts、Hibernate、MyBatis等）。</p>
<p><strong>⑥. 降低JavaEE API的使用难度</strong></p>
<p>Spring对JavaEE开发中非常难用的一些API（JDBC、JavaMail、远程调用等），都提供了封装，使这些API应用难度大大降低。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>Spring明明一个很轻量级的框架，却给人感觉大而全</li>
<li>Spring依赖反射，反射影响性能</li>
<li>使用门槛升高，入门Spring需要较长时间</li>
</ul>
</blockquote>
<h2 id="3-Spring有哪些模块"><a href="#3-Spring有哪些模块" class="headerlink" title="3. Spring有哪些模块"></a>3. Spring有哪些模块</h2><blockquote>
<ol>
<li><p><strong>Data Access&#x2F;Integration（数据访问／集成）</strong></p>
<p>数据访问／集成层包括 JDBC、ORM、OXM、JMS 和 Transactions 模块，具体介绍如下。</p>
<ul>
<li><strong>JDBC 模块：</strong>提供了一个 JBDC 的样例模板，使用这些模板能消除传统冗长的 JDBC 编码还有必须的事务控制，而且能享受到 Spring 管理事务的好处。</li>
<li><strong>ORM 模块：</strong>提供与流行的“对象-关系”映射框架无缝集成的 API，包括 JPA、JDO、Hibernate 和 MyBatis 等。而且还可以使用 Spring 事务管理，无需额外控制事务。</li>
<li>OXM 模块：提供了一个支持 Object &#x2F;XML 映射的抽象层实现，如 JAXB、Castor、XMLBeans、JiBX 和 XStream。将 Java 对象映射成 XML 数据，或者将XML 数据映射成 Java 对象。</li>
<li>JMS 模块：指 Java 消息服务，提供一套 “消息生产者、消息消费者”模板用于更加简单的使用 JMS，JMS 用于用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。</li>
<li>Transactions 事务模块：支持编程和声明式事务管理。</li>
</ul>
</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li><p><strong>Web模块</strong></p>
<p>Spring 的 Web 层包括 Web、Servlet、WebSocket 和 Portlet 组件，具体介绍如下。</p>
<ul>
<li>Web 模块：提供了基本的 Web 开发集成特性，例如多文件上传功能、使用的 Servlet 监听器的 IOC 容器初始化以及 Web 应用上下文。</li>
<li><strong>Servlet 模块：</strong>提供了一个 Spring MVC Web 框架实现。Spring MVC 框架提供了基于注解的请求资源注入、更简单的数据绑定、数据验证等及一套非常易用的 JSP 标签，完全无缝与 Spring 其他技术协作。</li>
<li>WebSocket 模块：提供了简单的接口，用户只要实现响应的接口就可以快速的搭建 WebSocket Server，从而实现双向通讯。</li>
<li>Portlet 模块：提供了在 Portlet 环境中使用 MVC 实现，类似 Web-Servlet 模块的功能。</li>
</ul>
</li>
</ol>
</blockquote>
<blockquote>
<ol start="3">
<li><p><strong>Core Container（Spring 的核心容器）</strong></p>
<ul>
<li><p><strong>Bean模块 - 核心容器的主要组件是 BeanFactory，它是工厂模式的实现。</strong></p>
<p><strong>BeanFactory 使用控制反转 （IOC） 模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。</strong></p>
</li>
<li><p><strong>Core 核心模块：封装了 Spring 框架的底层部分，包括资源访问、类型转换及一些常用工具类。</strong></p>
</li>
<li><p><strong>Context 上下文模块：建立在 Core 和 Beans 模块的基础之上，集成 Beans 模块功能并添加资源绑定、数据验证、国际化、Java EE 支持、容器生命周期、事件传播等。ApplicationContext 接口是上下文模块的焦点。</strong></p>
</li>
<li><p><strong>SpEL 模块：提供了强大的表达式语言支持，支持访问和修改属性值，方法调用，支持访问及修改数组、容器和索引器，命名变量，支持算数和逻辑运算，支持从 Spring 容器获取 Bean，它也支持列表投影、选择和一般的列表聚合等。</strong></p>
</li>
</ul>
</li>
</ol>
</blockquote>
<blockquote>
<ol start="4">
<li><strong>AOP、Aspects、Instrumentation 和 Messaging</strong><ul>
<li>AOP 模块：提供了面向切面编程实现，提供比如日志记录、权限控制、性能统计等通用功能和业务逻辑分离的技术，并且能动态的把这些功能添加到需要的代码中，这样各司其职，降低业务逻辑和通用功能的耦合。</li>
<li>Aspects 模块：提供与 AspectJ 的集成，是一个功能强大且成熟的面向切面编程（AOP）框架。</li>
<li>Instrumentation 模块：提供了类工具的支持和类加载器的实现，可以在特定的应用服务器中使用。</li>
<li>messaging 模块：Spring 4.0 以后新增了消息（Spring-messaging）模块，该模块提供了对消息传递体系结构和协议的支持。</li>
</ul>
</li>
</ol>
</blockquote>
<h2 id="4-Spring框架中用到了哪些设计模式"><a href="#4-Spring框架中用到了哪些设计模式" class="headerlink" title="4. Spring框架中用到了哪些设计模式"></a>4. Spring框架中用到了哪些设计模式</h2><blockquote>
<ol>
<li>工厂模式：BeanFactory就是简单工厂模式的体现，用来创建对象的实例；</li>
<li>单例模式：Bean默认为单例模式。</li>
<li>代理模式：Spring的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术；</li>
<li>模板方法：用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。</li>
<li>观察者模式：定义对象键一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知被制动更新，如Spring中listener的实现–ApplicationListener。</li>
</ol>
</blockquote>
<h2 id="5-Spring控制反转IOC-⭐️"><a href="#5-Spring控制反转IOC-⭐️" class="headerlink" title="5. Spring控制反转IOC ⭐️"></a>5. Spring控制反转IOC ⭐️</h2><h3 id="5-1-什么是IOC"><a href="#5-1-什么是IOC" class="headerlink" title="5.1 什么是IOC"></a>5.1 什么是IOC</h3><blockquote>
<p>控制反转即IoC (Inversion of Control)，它把传统上由程序代码直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理。所谓的“控制反转”概念就是对组件对象控制权的转移，从程序代码本身转移到了外部容器。</p>
<p><strong>Spring IOC 负责创建对象，管理对象（通过依赖注入（DI），装配对象，配置对象，并且管理这些对象的整个生命周期。</strong></p>
</blockquote>
<h3 id="5-2-IOC有什么作用"><a href="#5-2-IOC有什么作用" class="headerlink" title="5.2 IOC有什么作用"></a>5.2 IOC有什么作用</h3><blockquote>
<ul>
<li>管理对象的创建和依赖关系的维护。对象的创建并不是一件简单的事，在对象关系比较复杂时，如果依赖关系需要程序猿来维护的话，那是相当头疼的</li>
<li>解耦，由容器去维护具体的对象</li>
<li>托管了类的产生过程，比如我们需要在类的产生过程中做一些处理，最直接的例子就是代理，如果有容器程序可以把这部分处理交给容器，应用程序则无需去关心类是如何完成代理的</li>
</ul>
</blockquote>
<h3 id="5-3-IOC优点"><a href="#5-3-IOC优点" class="headerlink" title="5.3 IOC优点"></a>5.3 IOC优点</h3><blockquote>
<ul>
<li>IOC 或 依赖注入把应用的代码量降到最低。</li>
<li>它使应用容易测试，单元测试不再需要单例和JNDI查找机制。</li>
<li>最小的代价和最小的侵入性使松散耦合得以实现。</li>
<li>IOC容器支持加载服务时的饿汉式初始化和懒加载。</li>
</ul>
</blockquote>
<h3 id="5-4-正转和反转对比"><a href="#5-4-正转和反转对比" class="headerlink" title="5.4 正转和反转对比"></a>5.4 正转和反转对比</h3><blockquote>
<ul>
<li>正转 - 传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象.</li>
<li>反转 - <strong>由IoC容器来负责这些对象的创建,容器主动将资源推送给它所管理的组件，组件所要做的仅是选择一种合适的方式来接受资源，这种行为也被称为查找的被动形式</strong></li>
</ul>
</blockquote>
<h2 id="6-Spring依赖注入DI-⭐️"><a href="#6-Spring依赖注入DI-⭐️" class="headerlink" title="6. Spring依赖注入DI ⭐️"></a>6. Spring依赖注入DI ⭐️</h2><h3 id="6-1-什么是DI"><a href="#6-1-什么是DI" class="headerlink" title="6.1 什么是DI"></a>6.1 什么是DI</h3><blockquote>
<p>控制反转IoC是一个很大的概念，可以用不同的方式来实现。其主要实现方式有两种：依赖注入和依赖查找</p>
<p>依赖注入：相对于IoC而言，依赖注入(DI)更加准确地描述了IoC的设计理念。所谓依赖注入（Dependency Injection），<code>即组件之间的依赖关系由容器在应用系统运行期来决定，也就是由容器动态地将某种依赖关系的目标对象实例注入到应用系统中的各个关联的组件之中</code>。组件不做定位查询，只提供普通的Java方法让容器去决定依赖关系。</p>
</blockquote>
<h3 id="6-2-依赖注入的实现方式"><a href="#6-2-依赖注入的实现方式" class="headerlink" title="6.2 依赖注入的实现方式"></a>6.2 依赖注入的实现方式</h3><blockquote>
<p>依赖注入是时下最流行的IoC实现方式</p>
<ol>
<li><p>构造器依赖注入：构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。</p>
</li>
<li><p>Setter方法注入：Setter方法注入是容器通过调用无参构造器或无参static工厂 方法实例化bean之后，调用该bean的setter方法，即实现了基于setter的依赖注入。</p>
</li>
</ol>
</blockquote>
<h2 id="7-Spring框架中的单例bean是线程安全的吗？"><a href="#7-Spring框架中的单例bean是线程安全的吗？" class="headerlink" title="7. Spring框架中的单例bean是线程安全的吗？"></a>7. Spring框架中的单例bean是线程安全的吗？</h2><blockquote>
<p>不是，Spring框架中的单例bean不是线程安全的。</p>
<p>spring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理。</p>
<p>实际上大部分时候 spring bean 无状态的（比如 dao 类），所有某种程度上来说 bean 也是安全的，但如果 bean 有状态的话（比如 view model 对象），那就要开发者自己去保证线程安全了，<strong>最简单的就是改变 bean 的作用域，把“singleton”变更为“prototype”</strong>，这样请求 bean 相当于 new Bean()了，所以就可以保证线程安全了。</p>
<ul>
<li><strong>有状态就是有数据存储功能。</strong></li>
<li><strong>无状态就是不会保存数据</strong>。</li>
</ul>
</blockquote>
<h2 id="8-spring-自动装配-bean-有哪些方式-⭐️"><a href="#8-spring-自动装配-bean-有哪些方式-⭐️" class="headerlink" title="8. spring 自动装配 bean 有哪些方式? ⭐️"></a>8. spring 自动装配 bean 有哪些方式? ⭐️</h2><blockquote>
<p>在spring中，对象无需自己查找或创建与其关联的其他对象，由容器负责把需要相互协作的对象引用赋予各个对象，使用autowire来配置自动装载模式。</p>
<p>在Spring框架xml配置中共有5种自动装配：</p>
<ul>
<li>no：默认的方式是不进行自动装配的，通过手工设置ref属性来进行装配bean。</li>
<li><strong>byName：通过bean的名称进行自动装配，如果一个bean的 property 与另一bean 的name 相同，就进行自动装配。</strong></li>
<li><strong>byType：通过参数的数据类型进行自动装配。</strong></li>
<li>constructor：利用构造函数进行装配，并且构造函数的参数通过byType进行装配。</li>
<li>autodetect：自动探测，如果有构造方法，通过 construct的方式自动装配，否则使用 byType的方式自动装配。</li>
</ul>
</blockquote>
<h2 id="9-Autowired自动装配的规则"><a href="#9-Autowired自动装配的规则" class="headerlink" title="9. @Autowired自动装配的规则"></a>9. @Autowired自动装配的规则</h2><blockquote>
<p>在启动spring IoC时，容器自动装载了一个AutowiredAnnotationBeanPostProcessor后置处理器，当容器扫描到@Autowied、@Resource或@Inject时，就会在IoC容器自动查找需要的bean，并装配给该对象的属性。在使用@Autowired时，首先在容器中查询对应类型的bean：</p>
<ul>
<li>如果查询结果刚好为一个，就将该bean装配给@Autowired指定的数据；</li>
<li>如果查询的结果不止一个，那么@Autowired会根据名称来查找；</li>
<li>如果上述查找的结果为空，那么会抛出异常。解决方法时，使用required&#x3D;false。</li>
</ul>
</blockquote>
<h2 id="10-写出Spring中常用的注解"><a href="#10-写出Spring中常用的注解" class="headerlink" title="10. 写出Spring中常用的注解"></a>10. 写出Spring中常用的注解</h2><blockquote>
<p>@Component：这将 java 类标记为 bean。它是任何 Spring 管理组件的通用构造型。spring 的组件扫描机制现在可以将其拾取并将其拉入应用程序环境中。</p>
<p>@Controller：这将一个类标记为 Spring Web MVC 控制器。标有它的 Bean 会自动导入到 IoC 容器中。</p>
<p>@Service：此注解是组件注解的特化。它不会对 @Component 注解提供任何其他行为。您可以在服务层类中使用 @Service 而不是 @Component，因为它以更好的方式指定了意图。</p>
<p>@Repository：这个注解是具有类似用途和功能的 @Component 注解的特化。它为 DAO 提供了额外的好处。它将 DAO 导入 IoC 容器，并使未经检查的异常有资格转换为 Spring DataAccessException。</p>
<p>@Autowired: 自动装配</p>
<p>@RestController</p>
<p>@RequestMapping</p>
<p>@GetMapping @PostMapping …</p>
</blockquote>
<h2 id="11-什么是AOP-⭐️"><a href="#11-什么是AOP-⭐️" class="headerlink" title="11. 什么是AOP ⭐️"></a>11. 什么是AOP ⭐️</h2><blockquote>
<p>aop在项目中的应用 - 接口的幂等性 - <strong>防止表单重复提交⭐️</strong>,<strong>防止重复支付</strong></p>
</blockquote>
<blockquote>
<p>OOP(Object-Oriented Programming)面向对象编程，允许开发者定义纵向的关系，但并适用于定义横向的关系，导致了大量代码的重复，而不利于各个模块的重用。</p>
<p>AOP(Aspect-Oriented Programming)，一般称为面向切面编程，作为面向对象的一种补充<strong>，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面”（Aspect），减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。可用于权限认证、日志、事务处理等。</strong></p>
</blockquote>
<h3 id="11-1-JDK动态代理和CGLIB动态代理的区别"><a href="#11-1-JDK动态代理和CGLIB动态代理的区别" class="headerlink" title="11.1 JDK动态代理和CGLIB动态代理的区别"></a>11.1 JDK动态代理和CGLIB动态代理的区别</h3><blockquote>
<p><strong>Spring AOP中的动态代理主要有两种方式，JDK动态代理和CGLIB动态代理：</strong></p>
<ul>
<li><strong>JDK动态代理只提供接口的代理，</strong>不支持类的代理。核心InvocationHandler接口和Proxy类，InvocationHandler 通过invoke()方法反射来调用目标类中的代码，动态地将横切逻辑和业务编织在一起；接着，Proxy利用 InvocationHandler动态创建一个符合某一接口的的实例, 生成目标类的代理对象。</li>
<li>如果代理类没有实现 InvocationHandler 接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，<strong>可以在运行时动态的生成指定类的一个子类对象，并覆盖其中特定方法并添加增强代码，从而实现AOP</strong>。CGLIB是通过继承的方式做的动态代理，<strong>因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。</strong></li>
</ul>
<p>静态代理与动态代理区别在于生成AOP代理对象的时机不同，相对来说AspectJ的静态代理方式具有更好的性能，但是AspectJ需要特定的编译器进行处理，而Spring AOP则无需特定的编译器处理。</p>
<p>InvocationHandler 的 invoke(Object proxy,Method method,Object[] args)：proxy是最终生成的代理实例; method 是被代理目标实例的某个具体方法; args 是被代理目标实例某个方法的具体入参, 在方法反射调用时使用。</p>
</blockquote>
<h3 id="11-2-AOP名词"><a href="#11-2-AOP名词" class="headerlink" title="11.2 AOP名词"></a>11.2 AOP名词</h3><blockquote>
<ol>
<li><p>切面（Aspect）：切面是通知和切点的结合。通知和切点共同定义了切面的全部内容。 在Spring AOP中，切面可以使用通用（基于模式的风格） 或者在普通类中以 <strong>@AspectJ</strong> 注解来实现。</p>
<p><strong>横切关注点(跨越应用程序多个模块的功能)被模块化的特殊对象(与业务无关).Aspect &#x3D; Advice+PointCut</strong></p>
</li>
<li><p>连接点（Join point）：指方法，在Spring AOP中，<strong>一个连接点 总是 代表一个方法的执行</strong>。 应用可能有数以千计的时机应用通知。这些时机被称为连接点。连接点是在应用执行过程中能够插入切面的一个点。这个点可以是调用方法时、抛出异常时、甚至修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。</p>
<p>Spring支持方法级别的.</p>
</li>
<li><p>切入点（Pointcut）：切点的定义会匹配通知所要织入的一个或多个连接点。我们通常使用明确的类和方法名称，或是利用正则表达式定义所匹配的类和方法名称来指定这些切点。</p>
<p><strong>定义通知被应用的位置</strong></p>
</li>
<li><p>织入（Weaving）：织入是把<strong>切面应用到目标对象并创建新的代理对象的过程</strong>。在目标对象的生命周期里有多少个点可以进行织入</p>
</li>
</ol>
</blockquote>
<h3 id="11-3-Spring通知有哪些类型？"><a href="#11-3-Spring通知有哪些类型？" class="headerlink" title="11.3 Spring通知有哪些类型？"></a>11.3 Spring通知有哪些类型？</h3><blockquote>
<p>AOP术语中，切面的工作被称为通知，实际上是程序执行时要通过SpringAOP框架触发的代码段。</p>
<p>Spring切面可以应用5种类型的通知：</p>
<ol>
<li>前置通知（Before）：在目标方法被调用之前调用通知功能；</li>
<li>后置通知（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么；</li>
<li>返回通知（After-returning ）：在目标方法成功执行之后调用通知；</li>
<li>异常通知（After-throwing）：在目标方法抛出异常后调用通知；</li>
<li>环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。</li>
</ol>
<p>同一个aspect，不同advice的执行顺序：</p>
<p>①没有异常情况下的执行顺序：</p>
<ul>
<li>around before advice</li>
<li>before advice</li>
<li>target method 执行</li>
<li>around after advice</li>
<li>after advice</li>
<li>afterReturning</li>
</ul>
<p>②有异常情况下的执行顺序：</p>
<ul>
<li>around before advice</li>
<li>before advice</li>
<li>target method 执行</li>
<li>around after advice</li>
<li>after advice</li>
<li>afterThrowing:异常发生</li>
<li>java.lang.RuntimeException: 异常发生</li>
</ul>
</blockquote>
<h3 id="11-4-AOP在项目中应用"><a href="#11-4-AOP在项目中应用" class="headerlink" title="11.4 AOP在项目中应用"></a>11.4 AOP在项目中应用</h3><h2 id="12-Spring-事务实现方式有哪些-⭐️"><a href="#12-Spring-事务实现方式有哪些-⭐️" class="headerlink" title="12. Spring 事务实现方式有哪些? ⭐️"></a>12. Spring 事务实现方式有哪些? ⭐️</h2><blockquote>
<p>Spring支持两种类型的事务管理：</p>
<p>编程式事务管理：这意味你通过编程的方式管理事务，给你带来极大的灵活性，但是难维护。</p>
<ol start="2">
<li>声明式事务管理：<strong>这意味着你可以将业务代码和事务管理分离</strong>，你只需用注解和XML配置来管理事务。</li>
</ol>
</blockquote>
<h3 id="12-1-Spring的事务传播行为"><a href="#12-1-Spring的事务传播行为" class="headerlink" title="12.1 Spring的事务传播行为"></a>12.1 Spring的事务传播行为</h3><blockquote>
<p>① <strong>PROPAGATION_REQUIRED：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。</strong> 默认的</p>
<p>② PROPAGATION_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。</p>
<p>③ PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。</p>
<p>④ <strong>PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务。</strong></p>
<p>⑤ PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</p>
<p>⑥ PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。</p>
<p>⑦ PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则按REQUIRED属性执行。</p>
</blockquote>
<h2 id="13-BeanFactory-和-ApplicationContext有什么区别？"><a href="#13-BeanFactory-和-ApplicationContext有什么区别？" class="headerlink" title="13. BeanFactory 和 ApplicationContext有什么区别？"></a>13. BeanFactory 和 ApplicationContext有什么区别？</h2><blockquote>
<p>BeanFactory和ApplicationContext是Spring的两大核心接口，都可以当做S<strong>pring的容器。其中ApplicationContext是BeanFactory的子接口。</strong></p>
<ol>
<li><p>依赖关系</p>
<ul>
<li><p>BeanFactory：<strong>是Spring里面最底层的接口</strong>，包含了各种Bean的定义，读取bean配置文档，管理bean的加载、实例化，控制bean的生命周期，维护bean之间的依赖关系。</p>
<p>面向spring本身</p>
</li>
<li><p>ApplicationContext接口作为BeanFactory的派生，除了提供BeanFactory所具有的功能外，还提供了更完整的框架功能</p>
<p>sping框架使用者的</p>
</li>
</ul>
</li>
<li><p>加载方式</p>
<ul>
<li>BeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时(调用getBean())，才对该Bean进行加载实例化。这样，我们就不能发现一些存在的Spring的配置问题。如果Bean的某一个属性没有注入，BeanFacotry加载后，直至第一次使用调用getBean方法才会抛出异常。</li>
<li>ApplicationContext<strong>，它是在容器启动时，一次性创建了所有的Bean</strong>。这样，在容器启动时，我们就可以发现Spring中存在的配置错误，这样有利于检查所依赖属性是否注入。 ApplicationContext启动后预载入所有的单实例Bean，通过预载入单实例bean ,确保当你需要的时候，你就不用等待，因为它们已经创建好了。</li>
</ul>
<p>相对于基本的BeanFactory，ApplicationContext 唯一的不足是占用内存空间。当应用程序配置Bean较多时，程序启动较慢。</p>
</li>
</ol>
</blockquote>
<h2 id="14-Spring主要模块"><a href="#14-Spring主要模块" class="headerlink" title="14. Spring主要模块"></a>14. Spring主要模块</h2><blockquote>
<ul>
<li><strong>spring core：提供了框架的基本组成部分，包括控制反转（Inversion of Control，IOC）和依赖注入（Dependency Injection，DI）功能。</strong></li>
<li><strong>spring beans：提供了BeanFactory，是工厂模式的一个经典实现，Spring将管理对象称为Bean。</strong></li>
<li><strong>spring context：构建于 core 封装包基础上的 context 封装包，提供了一种框架式的对象访问方法。</strong></li>
<li>spring jdbc：提供了一个JDBC的抽象层，消除了烦琐的JDBC编码和数据库厂商特有的错误代码解析， 用于简化JDBC。</li>
<li><strong>spring aop：提供了面向切面的编程实现，让你可以自定义拦截器、切点等。</strong></li>
<li>spring Web：提供了针对 Web 开发的集成特性，例如文件上传，利用 servlet listeners 进行 ioc 容器初始化和针对 Web 的 ApplicationContext。</li>
<li>spring test：主要为测试提供支持的，支持使用JUnit或TestNG对Spring组件进行单元测试和集成测试。</li>
</ul>
</blockquote>
<h2 id="15-Bean生命周期⭐️"><a href="#15-Bean生命周期⭐️" class="headerlink" title="15. Bean生命周期⭐️"></a>15. Bean生命周期⭐️</h2><blockquote>
<p>最精简的生命周期 - bean的定义,bean的创建,bean的销毁的过程</p>
</blockquote>
<p><img src="/imgs/ioc.png"> </p>
<blockquote>
<ol>
<li><p>BeanDefinitionReader - 抽象接口 </p>
<p>比如重要的实现类 -  XmlBeanDefinitionReader[C] - 目的是得到BeanFactory - Bean工厂 - 工厂设计模式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BeanFactory[I]存储若干个BeanDefinition</span><br><span class="line">最底层的实现类DefaultListableBeanFactory[C]</span><br><span class="line"></span><br><span class="line"><span class="comment">//key - bean的name属性值,如果bean的name没有设置的话,那么默认会将bean标签的id属性值赋值给name属性值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap;</span><br></pre></td></tr></table></figure>
</li>
<li><p>BeanDefinition</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;tech.aistar.entity.User&quot;</span>&gt;</span></span><br><span class="line">解析xml文件,解析每个bean标签,每个bean标签中的信息就会使用内置对象BeanDefinition来进行存储.</span><br></pre></td></tr></table></figure>
</li>
<li><p>BeanFactoryPostProcessor  - Bean工厂的后置处理器 - 可以对BeanDefinition进行后置的修改.</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">比如:</span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;basicDataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">需要通过BeanFactoryPostProcessor将$&#123;driver&#125;替换成com.mysql.cj.jdbc.Driver.</span><br><span class="line">然后再将对应的bean信息封装到BeanDefinition[完整的bean定义对象]</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过反射实例化对象</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">类似于Class&lt;?&gt; c = Class.forName(&quot;tech.aistar.entity.User&quot;);</span><br><span class="line">User user = (User)c.newInstance();</span><br><span class="line"></span><br><span class="line">此时user尚未设置任何的属性值.只是在内存中开辟了一块区域</span><br></pre></td></tr></table></figure>
</li>
<li><p>具体对象实例化的过程 - 实例化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User&#123;id=null,name=null&#125;;//所有的属性尚未被初始化</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化的过程</p>
<p>填充属性 - setter&#x2F;构造</p>
</li>
<li><p>Aware接口 - Aware是一个具有标识作用的超级接口，实现该接口的bean是具有被spring 容器通知的能力的，而被通知的方式就是通过回调。也就是说：直接或间接实现了这个接口的类，都具有被spring容器通知的能力。</p>
</li>
<li><p>BeanPostProccesor#before - bean的后置处理器</p>
</li>
<li><p>init-method方法 - 初始化的方法</p>
</li>
<li><p>BeanPostProccesor#after- bean的后置处理器</p>
</li>
<li><p>完整的对象 - 单例池中&#x2F;直接返回这个对象 - 看bean的scope</p>
</li>
</ol>
</blockquote>
<blockquote>
<h3>BeanPostProccesor</h3>

<p>没有bean后置处理器的时候 - 实例化的过程:  构造 - 属性赋值 - init-method[初始化方法] -  destroy -method[销毁方法]</p>
<p>解释 - Spring中的后置处理器是我们的spring中的一个扩展点,需要开发者自己去实现一遍.插手我们spingbean实例化的过程.</p>
<p>它是在bean被放入到spring bean容器之前做的一个插手,可以对bean进行一个改变.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">实例化...</span><br><span class="line">setter-Id</span><br><span class="line">setter-name</span><br><span class="line">beanName-before:beanLife</span><br><span class="line">init...</span><br><span class="line">bean-after:tech.aistar.day04.BeanLife@5579bb86</span><br><span class="line">destroy...</span><br></pre></td></tr></table></figure>
</blockquote>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title="0" data-url="http://link.hhtjim.com/163/22821023.mp3"></li>
                        
                    
                        
                            <li title="1" data-url="http://link.hhtjim.com/163/441116287.mp3"></li>
                        
                    
                        
                            <li title="2" data-url="http://link.hhtjim.com/163/509726618.mp3"></li>
                        
                    
                        
                            <li title="3" data-url="http://link.hhtjim.com/163/465262028.mp3"></li>
                        
                    
                        
                            <li title="4" data-url="http://link.hhtjim.com/163/1357220737.mp3"></li>
                        
                    
                </ul>
            
        </div>
        
        
    <div id="gitalk-container" class="comment link"
		data-enable="false"
        data-ae="false"
        data-ci=""
        data-cs=""
        data-r=""
        data-o=""
        data-a=""
        data-d="false"
    >查看评论</div>


    </div>
    
        <div class="side">
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-Spring%E9%83%A8%E5%88%86"><span class="toc-number">1.</span> <span class="toc-text">1. Spring部分</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9spring%E6%A1%86%E6%9E%B6%E7%9A%84%E8%AE%A4%E8%AF%86"><span class="toc-number">1.1.</span> <span class="toc-text">1. 谈谈你对spring框架的认识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Spring%E6%A1%86%E6%9E%B6%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">1.2.</span> <span class="toc-text">2. Spring框架优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.2.0.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">1.2.0.2.</span> <span class="toc-text">缺点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Spring%E6%9C%89%E5%93%AA%E4%BA%9B%E6%A8%A1%E5%9D%97"><span class="toc-number">1.3.</span> <span class="toc-text">3. Spring有哪些模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%94%A8%E5%88%B0%E4%BA%86%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.4.</span> <span class="toc-text">4. Spring框架中用到了哪些设计模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Spring%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%ACIOC-%E2%AD%90%EF%B8%8F"><span class="toc-number">1.5.</span> <span class="toc-text">5. Spring控制反转IOC ⭐️</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E4%BB%80%E4%B9%88%E6%98%AFIOC"><span class="toc-number">1.5.1.</span> <span class="toc-text">5.1 什么是IOC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-IOC%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="toc-number">1.5.2.</span> <span class="toc-text">5.2 IOC有什么作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-IOC%E4%BC%98%E7%82%B9"><span class="toc-number">1.5.3.</span> <span class="toc-text">5.3 IOC优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E6%AD%A3%E8%BD%AC%E5%92%8C%E5%8F%8D%E8%BD%AC%E5%AF%B9%E6%AF%94"><span class="toc-number">1.5.4.</span> <span class="toc-text">5.4 正转和反转对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Spring%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5DI-%E2%AD%90%EF%B8%8F"><span class="toc-number">1.6.</span> <span class="toc-text">6. Spring依赖注入DI ⭐️</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E4%BB%80%E4%B9%88%E6%98%AFDI"><span class="toc-number">1.6.1.</span> <span class="toc-text">6.1 什么是DI</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">1.6.2.</span> <span class="toc-text">6.2 依赖注入的实现方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-Spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8Bbean%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97%EF%BC%9F"><span class="toc-number">1.7.</span> <span class="toc-text">7. Spring框架中的单例bean是线程安全的吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-spring-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D-bean-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F-%E2%AD%90%EF%B8%8F"><span class="toc-number">1.8.</span> <span class="toc-text">8. spring 自动装配 bean 有哪些方式? ⭐️</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-Autowired%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-number">1.9.</span> <span class="toc-text">9. @Autowired自动装配的规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E5%86%99%E5%87%BASpring%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.10.</span> <span class="toc-text">10. 写出Spring中常用的注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E4%BB%80%E4%B9%88%E6%98%AFAOP-%E2%AD%90%EF%B8%8F"><span class="toc-number">1.11.</span> <span class="toc-text">11. 什么是AOP ⭐️</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1-JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8CCGLIB%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.11.1.</span> <span class="toc-text">11.1 JDK动态代理和CGLIB动态代理的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-AOP%E5%90%8D%E8%AF%8D"><span class="toc-number">1.11.2.</span> <span class="toc-text">11.2 AOP名词</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-3-Spring%E9%80%9A%E7%9F%A5%E6%9C%89%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="toc-number">1.11.3.</span> <span class="toc-text">11.3 Spring通知有哪些类型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-4-AOP%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%BA%94%E7%94%A8"><span class="toc-number">1.11.4.</span> <span class="toc-text">11.4 AOP在项目中应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-Spring-%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B-%E2%AD%90%EF%B8%8F"><span class="toc-number">1.12.</span> <span class="toc-text">12. Spring 事务实现方式有哪些? ⭐️</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-1-Spring%E7%9A%84%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA"><span class="toc-number">1.12.1.</span> <span class="toc-text">12.1 Spring的事务传播行为</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-BeanFactory-%E5%92%8C-ApplicationContext%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.13.</span> <span class="toc-text">13. BeanFactory 和 ApplicationContext有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-Spring%E4%B8%BB%E8%A6%81%E6%A8%A1%E5%9D%97"><span class="toc-number">1.14.</span> <span class="toc-text">14. Spring主要模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E2%AD%90%EF%B8%8F"><span class="toc-number">1.15.</span> <span class="toc-text">15. Bean生命周期⭐️</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.15.1.</span> <span class="toc-text">BeanPostProccesor</span></a></li></ol></li></ol></li></ol>
        </div>
    
</div>


    </div>
</div>
</body>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>






</html>
