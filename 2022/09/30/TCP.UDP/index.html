
<!DOCTYPE html>
<html lang="zh-CN" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>零散 - 勉~杌子生的博客</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="Fechin,"> 
    <meta name="description" content="1. Restful了解多少
核心:用HTTP动作来操作服务器的资源


REST（Representational State Transfer）是”表现层状态转化”。如果一个架构符合REST原则,"> 
    <meta name="author" content="Fstoer BG"> 
    <link rel="alternative" href="atom.xml" title="勉~杌子生的博客" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
    
    
    <meta name="twitter:card" content="summary"/>
    <meta name="twitter:title" content="零散 - 勉~杌子生的博客"/>
    <meta name="twitter:description" content="1. Restful了解多少
核心:用HTTP动作来操作服务器的资源


REST（Representational State Transfer）是”表现层状态转化”。如果一个架构符合REST原则,"/>
    
    
    
    
    <meta property="og:site_name" content="勉~杌子生的博客"/>
    <meta property="og:type" content="object"/>
    <meta property="og:title" content="零散 - 勉~杌子生的博客"/>
    <meta property="og:description" content="1. Restful了解多少
核心:用HTTP动作来操作服务器的资源


REST（Representational State Transfer）是”表现层状态转化”。如果一个架构符合REST原则,"/>
    
<link rel="stylesheet" href="/css/diaspora.css">

    <script>window.searchDbPath = "/search.xml";</script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
<meta name="generator" content="Hexo 6.2.0"></head>

<body class="loading">
    <span id="config-title" style="display:none">勉~杌子生的博客</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="https://fstoer-1.github.io"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">零散</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">零散</h1>
        <div class="stuff">
            <span>九月 30, 2022</span>
            
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/TCP-UDP/" rel="tag">TCP&#x2F;UDP</a></li></ul>


        </div>
        <div class="content markdown">
            <h1 id="1-Restful了解多少"><a href="#1-Restful了解多少" class="headerlink" title="1. Restful了解多少"></a>1. Restful了解多少</h1><blockquote>
<p>核心:用HTTP动作来操作服务器的资源</p>
</blockquote>
<blockquote>
<p>REST（Representational State Transfer）是”表现层状态转化”。如果一个架构符合REST原则，就称它为RESTful架构。</p>
<p>REST的名称”表现层状态转化”中，省略了主语。**”表现层”其实指的是”资源”的”表现层”**</p>
<p>总结性风格说明</p>
<ul>
<li>每个资源对应一个url,用url来定位资源,并且url命名规范 - 名词</li>
<li>用http方法对应资源的操作.</li>
<li>使用json来作为数据交互的格式.</li>
<li>使用http状态码来表示操作的结果.</li>
</ul>
</blockquote>
<h1 id="2-接口的幂等性"><a href="#2-接口的幂等性" class="headerlink" title="2. 接口的幂等性"></a>2. 接口的幂等性</h1><blockquote>
<p>对于同一个内容的请求，发出n次的效果与发出1次的效果相同</p>
</blockquote>
<table>
<thead>
<tr>
<th>Method</th>
<th align="center">安全性</th>
<th align="center">幂等性</th>
</tr>
</thead>
<tbody><tr>
<td>GET</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td>HEAD</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td>POST</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
<tr>
<td>PUT</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
<tr>
<td>PATCH</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
<tr>
<td>DELETE</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
</tbody></table>
<h1 id="3-如何防止表单重复提交"><a href="#3-如何防止表单重复提交" class="headerlink" title="3. 如何防止表单重复提交"></a>3. 如何防止表单重复提交</h1><blockquote>
<ol>
<li><p>js禁用按钮</p>
</li>
<li><p>提交完,重新到其他的url</p>
</li>
<li><p><strong>session+token  推荐答案</strong></p>
<blockquote>
<ol>
<li><p>client请求先到&#x2F;form - 在第一次请求到达jsp页面之前</p>
<p>在server端生成一个token,并且将这个token存储到 session&#x2F;redis中即可.  </p>
</li>
<li><p>return “day06&#x2F;index”;</p>
<p>在该jsp页面的form表单中增加一个隐藏域,并且这个隐藏域的值就是来自于刚刚作用域中存储的token</p>
</li>
<li><p>按钮触发事件,一旦提交form表单,将这个隐藏域中的token一并发送到server端 - &#x2F;form&#x2F;register</p>
</li>
<li><p>将表单提交过来的token和session中的token进行一个比较.如果一样.则顺利执行我们的业务.</p>
</li>
<li><p>第一次顺利执行我们的业务操作之后,则删除session&#x2F;redis中的存储的token</p>
</li>
<li><p>重复提交表单[刷新,按钮],还是将隐藏域中的token再次发送并且和server端session&#x2F;redis中的token进行比较.这个时候比较会失败.因为经过第一次业务操作之后,server端已经将session&#x2F;redis中的token删除了.</p>
</li>
</ol>
</blockquote>
<blockquote>
<p><code>代码比较冗余 - 凡是需要防止表单重复提交的动作,都需要写这种与业务无关的代码</code></p>
</blockquote>
</li>
</ol>
</blockquote>
<blockquote>
<ol start="4">
<li>AOP + Token + Session&#x2F;Redis + 自定义注解 + 全局异常处理器</li>
</ol>
</blockquote>
<h1 id="4-消息队列的优缺点"><a href="#4-消息队列的优缺点" class="headerlink" title="4. 消息队列的优缺点"></a>4. 消息队列的优缺点</h1><blockquote>
<p><code>优点:</code></p>
</blockquote>
<blockquote>
<p>（1）解耦：将系统按照不同的业务功能拆分出来，消息生产者只管把消息发布到 MQ 中而不用管谁来取，消息消费者只管从 MQ 中取消息而不管是谁发布的。消息生产者和消费者都不知道对方的存在；</p>
<p>（2）异步：主流程只需要完成业务的核心功能；对于业务非核心功能，将消息放入到消息队列之中进行异步处理，减少请求的等待，提高系统的总体性能；</p>
<p>（3）削峰&#x2F;限流：将所有请求都写到消息队列中，消费服务器按照自身能够处理的请求数从队列中拿到请求，防止请求并发过高将系统搞崩溃；</p>
</blockquote>
<blockquote>
<p><code>缺点:</code></p>
<p>（1）系统的可用性降低：系统引用的外部依赖越多，越容易挂掉，如果MQ 服务器挂掉，那么可能会导致整套系统崩溃。这时就要考虑如何保证消息队列的高可用了</p>
<p>（2）系统复杂度提高：加入消息队列之后，需要保证消息没有重复消费、如何处理消息丢失的情况、如何保证消息传递的有序性等问题；</p>
<p>（3）数据一致性问题：A 系统处理完了直接返回成功了，使用者都以为你这个请求就成功了；但是问题是，要是 BCD 三个系统那里，BD 两个系统写库成功了，结果 C 系统写库失败了，就会导致数据不一致了</p>
</blockquote>
<h1 id="5-如何保证消息不被重复消费"><a href="#5-如何保证消息不被重复消费" class="headerlink" title="5. 如何保证消息不被重复消费"></a>5. 如何保证消息不被重复消费</h1><blockquote>
<ol>
<li><p>业务场景1：从生产者拿到个数据后要写库，先根据主键查一下，如果这个数据有了就别插了直接update</p>
</li>
<li><p>业务场景2：如果是写redis的都没问题，因为每次都是set，redis天然的幂等性</p>
</li>
<li><p>利用Redis，首先系统生成<strong>全局唯一的 id</strong>，用set操作放入Redis中<br>3-1. 如订单信息id，消费后存储在Redis中，如果下次再来，先查看Redis中是否存在<br>3-2. 如果存在，即此消息已经被消费过（后续不做消费处理）<br>3-3. 如果不存在，即未消费，此时再将此id存入Redis中，进行后续的逻辑操作</p>
</li>
</ol>
</blockquote>
<h1 id="6-如何保证消息不丢失"><a href="#6-如何保证消息不丢失" class="headerlink" title="6. 如何保证消息不丢失"></a>6. 如何保证消息不丢失</h1><blockquote>
<ol>
<li><p>rabbitmq自己丢了数据 - 生产者</p>
<blockquote>
<p><strong>设置消息持久化到磁盘</strong>。设置持久化有两个步骤： ①<strong>创建queue的时候将其设置为持久化的</strong>，这样就可以保证rabbitmq持久化queue的元数据，但是不会持久化queue里面的数据。 ②发送消息的时候讲消息的deliveryMode设置为2，这样<strong>消息就会被设为持久化方式</strong>，此时rabbitmq就会将消息持久化到磁盘上。 必须要<strong>同时开启这两个才可以</strong>。</p>
<p>而且持久化可以跟生产的<strong>confirm机制配合起来</strong>，只有消息持久化到了磁盘之后，才会通知生产者ack，这样就算是在持久化之前rabbitmq挂了，数据丢了，生产者收不到ack回调也会进行消息重发。</p>
</blockquote>
</li>
<li><p>消费者端弄丢数据</p>
<blockquote>
<p>使用rabbitmq提供的ack机制，首先关闭rabbitmq的自动ack，然后每次在确保处理完这个消息之后，在代码里手动调用ack。这样就可以避免消息还没有处理完就ack。</p>
</blockquote>
</li>
</ol>
</blockquote>
<h1 id="7-解释下死信队列"><a href="#7-解释下死信队列" class="headerlink" title="7. 解释下死信队列"></a>7. 解释下死信队列</h1><blockquote>
<p>“死信”是RabbitMQ中的一种消息机制，当你在消费消息时，如果队列里的消息出现以下情况：</p>
<ol>
<li><p>消息被否定确认，使用 channel.basicNack 或 channel.basicReject ，并且此时requeue 属性被设置为false。</p>
</li>
<li><p>消息在队列的存活时间超过设置的TTL时间。</p>
</li>
<li><p>消息队列的消息数量已经超过最大队列长度。</p>
</li>
</ol>
<p>那么该消息将成为“死信”。</p>
<h2 id="“死信”消息会被RabbitMQ进行特殊处理，如果配置了死信队列信息，那么该消息将会被丢进死信队列中，如果没有配置，则该消息将会被丢弃。"><a href="#“死信”消息会被RabbitMQ进行特殊处理，如果配置了死信队列信息，那么该消息将会被丢进死信队列中，如果没有配置，则该消息将会被丢弃。" class="headerlink" title="“死信”消息会被RabbitMQ进行特殊处理，如果配置了死信队列信息，那么该消息将会被丢进死信队列中，如果没有配置，则该消息将会被丢弃。"></a>“死信”消息会被RabbitMQ进行特殊处理，如果配置了死信队列信息，那么该消息将会被丢进死信队列中，如果没有配置，则该消息将会被丢弃。</h2></blockquote>
<h1 id="8-解释下延时-x2F-延迟队列"><a href="#8-解释下延时-x2F-延迟队列" class="headerlink" title="8. 解释下延时&#x2F;延迟队列"></a>8. 解释下延时&#x2F;延迟队列</h1><blockquote>
<p>延迟队列也是一个消息队列，只是它是一个带延迟功能的消息队列。简单说，在实际开发中，对于某些业务场景，我们需要让队列中的消息在指定时间时候才被消费者消费，例如：</p>
<p>场景一：订单下单之后一定时间未支付会自动取消订单<br>场景二：涉及到T+d（工作日延迟）或者D+d（自然日延迟）等延迟交付的场景<br>场景三：新用户注册之后一个月没有下单，发个短信勾引一波</p>
<p>可能有人会问，以上情况，我起个定时任务轮询处理，也能达到目的。是的，确实能达到目的，但是如果在该类业务数据量大的情况，处理起来就会十分麻烦，对服务器造成较大压力，并且轮询会有较大误差产生。如果使用延时队列来完成可以避免此类问题。<br>rabbitmq本身是不直接支持延时队列的，<strong>RabbitMQ的延迟队列基于消息的存活时间TTL（Time To Live）和死信交换机DLE（Dead Letter Exchanges）实现</strong></p>
</blockquote>
<h1 id="9-如何保证消息的顺序性"><a href="#9-如何保证消息的顺序性" class="headerlink" title="9. 如何保证消息的顺序性"></a>9. 如何保证消息的顺序性</h1><blockquote>
<p> 比如有三个请求，是对数据库中的同一条数据进行了<strong>插入-&gt;更新-&gt;删除操作</strong>，执行顺序必须保证，如果变成删除-&gt;更新-&gt;插入就很可笑了，造成最终数据不一致。</p>
<p>顺序错乱的场景：</p>
<p>  一个queue，有多个consumer去消费，这样就会造成顺序的错误，consumer从MQ里面读取数据是有序的，但是每个consumer的执行时间是不固定的，无法保证先读到消息的consumer一定先执行完操作，这样就会出现消息并没有按照顺序执行，造成数据顺序错误。</p>
<p>rabbitmq如何保证消息的消费顺序</p>
<p>将原来的一个queue拆分成多个queue，每个queue都有一个自己的consumer。该种方案的核心是生产者在投递消息的时候根据业务数据关键值（例如订单ID哈希值对订单队列数取模）来将<strong>需要保证先后顺序的同一类数据（同一个订单的数据） 发送到同一个queue当中，让同一个consumer来按顺序处理。</strong></p>
</blockquote>
<h1 id="10-四种交换机-7种工作模式"><a href="#10-四种交换机-7种工作模式" class="headerlink" title="10. 四种交换机+7种工作模式"></a>10. 四种交换机+7种工作模式</h1><blockquote>
<p>交换机**:direct topic fanout** headers</p>
<p>工作模式:简单模式,工作队列模式,发布订阅模式,路由模式,主题模式</p>
</blockquote>
<h1 id="11-nginx了解多少"><a href="#11-nginx了解多少" class="headerlink" title="11. nginx了解多少"></a>11. nginx了解多少</h1><blockquote>
<ol>
<li><p>可以用来解决跨域</p>
</li>
<li><p>可以用来做负载均衡</p>
<p>nginx.conf</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">upstream item &#123; # item名字可以自定义</span><br><span class="line">                server localhost:8081</span><br><span class="line">                server localhost:8082</span><br><span class="line">            &#125;</span><br><span class="line">location /&#123;</span><br><span class="line">                proxy_pass http://item;     # item是在上面命名的</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</blockquote>
<h2 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h2><blockquote>
<p><strong>nginx属于服务器端的负载均衡，</strong>客户端所有的请求都统一交给我们的Nginx，在由我们的nginx转发到我们的真实服务实现负载均衡。</p>
</blockquote>
<blockquote>
<ol>
<li><p>默认是轮询模式</p>
</li>
<li><p>指定权重</p>
<p>指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream backserver &#123; </span><br><span class="line">  server 192.168.0.14 weight=8; </span><br><span class="line">  server 192.168.0.15 weight=10; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>IP绑定 ip_hash</p>
<p>每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream backserver &#123; </span><br><span class="line">  ip_hash; </span><br><span class="line">  server 192.168.0.14:88; </span><br><span class="line">  server 192.168.0.15:80; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>第三方 - fair</p>
</li>
</ol>
</blockquote>
<h1 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h1><blockquote>
<p><strong>面试:为什么需要三次握手,2次握手为什么不行?</strong></p>
</blockquote>
<blockquote>
<p>三次握手的原文是 <code>three-way handshake</code>，整个名词的可以翻译为：<strong>需要三个步骤才能建立握手&#x2F;连接的机制</strong>。当然，三次握手也可以叫 <code>three-message handshake</code>，通过三条消息来建立的握手&#x2F;连接。</p>
<p>进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的 <strong>初始化序列号(Init Sequense Number, <code>ISN</code>)</strong> 为后面的可靠性传输做准备。</p>
</blockquote>
<blockquote>
<p><img src="/%E9%9B%B6%E6%95%A3%E5%85%B6%E4%BB%96%E5%A4%8D%E4%B9%A0/tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B-1664543472017.png"> </p>
</blockquote>
<blockquote>
<ul>
<li>SYN&#96;：连接请求&#x2F;接收 报文段</li>
<li><code>seq</code>：发送的第一个字节的序号</li>
<li><code>ACK</code>：确认报文段</li>
<li><code>ack</code>：确认号。希望收到的下一个数据的第一个字节的序号</li>
</ul>
</blockquote>
<blockquote>
<ol>
<li><p><strong>第一次握手</strong>：客户端向服务端发送一个 SYN 报文（SYN &#x3D; 1），并指明客户端的初始化序列号 ISN(x)，即图中的 seq &#x3D; x，表示本报文段所发送的数据的第一个字节的序号。此时客户端处于 <code>SYN_Send</code> 状态。</p>
<blockquote>
<p>&#96;&#96;SYN-SENT<code> ：在发送连接请求后等待匹配的连接请求</code></p>
<p><code>确定服务器端是否具备接受能力</code></p>
</blockquote>
</li>
<li><p><strong>第二次握手</strong>：服务器收到客户端的 SYN 报文之后，会发送 SYN 报文作为应答（SYN &#x3D; 1），并且指定自己的初始化序列号 ISN(y)，即图中的 seq &#x3D; y。同时会把客户端的 ISN + 1 作为确认号 ack 的值，表示已经收到了客户端发来的的 SYN 报文，希望收到的下一个数据的第一个字节的序号是 x + 1，此时服务器处于 <code>SYN_REVD</code> 的状态。</p>
<blockquote>
<p><code>SYN-RECEIVED</code>：在收到和发送一个连接请求后等待对连接请求的确认</p>
<p><code>服务器端想要确定客户端是否具备局接受能力</code></p>
</blockquote>
</li>
<li><p><strong>第三次握手</strong>：客户端收到服务器端响应的 SYN 报文之后，会发送一个 ACK 报文，也是一样把服务器的 ISN + 1 作为 ack 的值，表示已经收到了服务端发来的的 SYN 报文，希望收到的下一个数据的第一个字节的序号是 y + 1，并指明此时客户端的序列号 seq &#x3D; x + 1（初始为 seq &#x3D; x，所以第二个报文段要 +1），此时客户端处于 <code>Establised</code> 状态。</p>
<p><code>服务器收到 ACK 报文之后，也处于 </code>Establised 状态<code>，至此，双方建立起了 TCP 连接。</code></p>
<blockquote>
<p>&#96;&#96;ESTABLISHED<code>：代表一个打开的连接，数据可以传送给用户</code></p>
<p><code>客户端告诉服务器端,我有接受能力</code></p>
</blockquote>
</li>
</ol>
</blockquote>
<p><code>通俗一点图示</code></p>
<p><img src="/%E9%9B%B6%E6%95%A3%E5%85%B6%E4%BB%96%E5%A4%8D%E4%B9%A0/tcp3-1664543472017.png"> </p>
<h3 id="为什么2次握手不行-必须要3次握手"><a href="#为什么2次握手不行-必须要3次握手" class="headerlink" title="为什么2次握手不行,必须要3次握手"></a>为什么2次握手不行,必须要3次握手</h3><blockquote>
<p>①client发送了SYN,由于网络波动,没有到达server,server就不会响应.</p>
<p>②client就会再次发送SYN,顺利到达server &#x3D;&gt; 顺利完成了3次握手</p>
<p>③网络突然好了呀.迟到的SYN数据包到server,server以为client又发生了建立请求.所以进行了二次握手.</p>
<p>对于client,觉得”莫名其妙”,自己并没有发任何的SYN,所以不会响应.    但是此时tcp已经建立好了.  server一直在等.占用server端资源.</p>
</blockquote>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><blockquote>
<p>为什么需要四次挥手?</p>
<p>为什么需要等待2msl超时等待时间?</p>
<p>①客户端发送FIN&#x3D;1,告诉server,我要断开连接了.</p>
<p>②server发送ACK&#x3D;1,好的吧!server会开始通知一些应用进程.</p>
<p>③server再次发送一个FIN&#x3D;1和ACK&#x3D;1发送给client,我已经处于关闭等待状态了</p>
<p>④client会发送ACK&#x3D;1到server,那我断开连接了哈!server会直接关闭,先关闭server</p>
<p>⑤client为什么为什么需要超时等待一段时间之后,才会close.</p>
<p>​    因为防止在第④发送的ACK,seq,ack没有顺利到达server端.确保server先close.最后client才会关闭.</p>
</blockquote>
<blockquote>
<p><img src="/%E9%9B%B6%E6%95%A3%E5%85%B6%E4%BB%96%E5%A4%8D%E4%B9%A0/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B-1664543472017.png"> </p>
</blockquote>
<h1 id="四种web通讯方式"><a href="#四种web通讯方式" class="headerlink" title="四种web通讯方式"></a>四种web通讯方式</h1><blockquote>
<ol>
<li><p>短轮询</p>
<p>http端轮询是服务器收到请求不管是否有数据都直接响应 http 请求;<br>其实就是普通的轮询。指在特定的的时间间隔（如每1秒），由浏览器对服务器发出HTTP request，然后由服务器返回最新的数据给客户端的浏览器。</p>
<ul>
<li>传统的web通信模式。后台处理数据，需要一定时间，前端想要知道后端的处理结果，就要不定时的向后端发出请求以获得最新情况。</li>
</ul>
<ul>
<li><p><strong>请求中有大半是无用，难于维护，浪费带宽和服务器资源；</strong></p>
<ul>
<li>响应的结果没有顺序（因为是异步请求，当发送的请求没有返回结果的时候，后面的请求又被发送。而此时如果后面的请求比前面的请 求要先返回结果，那么当前面的请求返回结果数据时已经是过时无效的数据了）。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"> <span class="built_in">setInterval</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>,<span class="string">&#x27;/user&#x27;</span>);</span><br><span class="line">  xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line">  xhr.<span class="title function_">send</span>();</span><br><span class="line">			     &#125;,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>长轮询</p>
<blockquote>
<p>首先由客户端向服务器发起请求，当服务器收到客户端发来的请求后，<strong>服务器端不会直接进行响应</strong>，而是先将 这个请求挂起，然后<strong>判断服务器端数据是否有更新</strong>。<strong>如果有更新，则进行响应</strong>，如果一直没有数据，则到达一定的时间限制才返回。 客户端 JavaScript 响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接。长轮询和短轮询比起来，<strong>它的 优点是明显减少了很多不必要的 http 请求次数</strong>，相比之下节约了资源。<strong>长轮询的缺点在于，连接挂起也会导致资源的浪费</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function <span class="title function_">ajax</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">var</span> <span class="variable">xhr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.open(<span class="string">&#x27;GET&#x27;</span>,<span class="string">&#x27;/user&#x27;</span>);</span><br><span class="line">xhr.onreadystatechange = function()&#123;</span><br><span class="line"><span class="keyword">if</span>()&#123;</span><br><span class="line">	ajax();</span><br><span class="line">&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	xhr.send();</span><br><span class="line">	&#125;</span><br><span class="line">ajax();</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>短连接</p>
<blockquote>
<p>在HTTP 0.9和HTTP 1.0中默认使用短连接。也就是说，<strong>客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。</strong></p>
<p>当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。</p>
</blockquote>
<blockquote>
<p>每次Http请求都会建立Tcp连接</p>
</blockquote>
</li>
<li><p>长连接</p>
<blockquote>
<p><strong>HTTP1.0已经开始支持了.但是默认还是短连接.HTTP1.1默认支持长连接</strong></p>
</blockquote>
<blockquote>
<p>只需要建立一次Tcp连接，以后Http请求重复使用同一个Tcp连接</p>
</blockquote>
</li>
<li><p>websocket</p>
<blockquote>
<p>在<em>HTTP</em>协议中通信只能由客户端发起，<strong>服务器不能主动向客户端推送消息</strong></p>
<p>当建立起WebSocket的长连接，双方都可以互相发送信息，服务端可以主动发起信息。</p>
<p>WebSocket API 中，浏览器和服务器只需要<strong>完成一次握手</strong>，两者之间就直接可以创建<strong>长连接</strong>，并进行<strong>双向数据传输</strong>。</p>
</blockquote>
</li>
</ol>
</blockquote>
<h1 id="UDP介绍"><a href="#UDP介绍" class="headerlink" title="UDP介绍"></a>UDP介绍</h1><blockquote>
<p><strong>用户数据报协议 UDP</strong>（User Datagram Protocol）</p>
<ul>
<li><strong>UDP 在传送数据之前不需要先建立连接</strong>，远程主机在收到 UDP 报文后，不需要给出任何确认。</li>
<li>虽然 UDP <strong>不提供可靠交付</strong>，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于<strong>即时通信</strong>），比如： QQ 语音、 QQ 视频 、直播等等.</li>
<li>tcp面向流的,udp是面向报文</li>
</ul>
</blockquote>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title="0" data-url="http://link.hhtjim.com/163/22821023.mp3"></li>
                        
                    
                        
                            <li title="1" data-url="http://link.hhtjim.com/163/441116287.mp3"></li>
                        
                    
                        
                            <li title="2" data-url="http://link.hhtjim.com/163/509726618.mp3"></li>
                        
                    
                        
                            <li title="3" data-url="http://link.hhtjim.com/163/465262028.mp3"></li>
                        
                    
                        
                            <li title="4" data-url="http://link.hhtjim.com/163/1357220737.mp3"></li>
                        
                    
                </ul>
            
        </div>
        
        
    <div id="gitalk-container" class="comment link"
		data-enable="false"
        data-ae="false"
        data-ci=""
        data-cs=""
        data-r=""
        data-o=""
        data-a=""
        data-d="false"
    >查看评论</div>


    </div>
    
        <div class="side">
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-Restful%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%B0%91"><span class="toc-number">1.</span> <span class="toc-text">1. Restful了解多少</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B9%82%E7%AD%89%E6%80%A7"><span class="toc-number">2.</span> <span class="toc-text">2. 接口的幂等性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E8%A1%A8%E5%8D%95%E9%87%8D%E5%A4%8D%E6%8F%90%E4%BA%A4"><span class="toc-number">3.</span> <span class="toc-text">3. 如何防止表单重复提交</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">4.</span> <span class="toc-text">4. 消息队列的优缺点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E8%A2%AB%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9"><span class="toc-number">5.</span> <span class="toc-text">5. 如何保证消息不被重复消费</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1"><span class="toc-number">6.</span> <span class="toc-text">6. 如何保证消息不丢失</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E8%A7%A3%E9%87%8A%E4%B8%8B%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97"><span class="toc-number">7.</span> <span class="toc-text">7. 解释下死信队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%80%9C%E6%AD%BB%E4%BF%A1%E2%80%9D%E6%B6%88%E6%81%AF%E4%BC%9A%E8%A2%ABRabbitMQ%E8%BF%9B%E8%A1%8C%E7%89%B9%E6%AE%8A%E5%A4%84%E7%90%86%EF%BC%8C%E5%A6%82%E6%9E%9C%E9%85%8D%E7%BD%AE%E4%BA%86%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97%E4%BF%A1%E6%81%AF%EF%BC%8C%E9%82%A3%E4%B9%88%E8%AF%A5%E6%B6%88%E6%81%AF%E5%B0%86%E4%BC%9A%E8%A2%AB%E4%B8%A2%E8%BF%9B%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97%E4%B8%AD%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%B2%A1%E6%9C%89%E9%85%8D%E7%BD%AE%EF%BC%8C%E5%88%99%E8%AF%A5%E6%B6%88%E6%81%AF%E5%B0%86%E4%BC%9A%E8%A2%AB%E4%B8%A2%E5%BC%83%E3%80%82"><span class="toc-number">7.1.</span> <span class="toc-text">“死信”消息会被RabbitMQ进行特殊处理，如果配置了死信队列信息，那么该消息将会被丢进死信队列中，如果没有配置，则该消息将会被丢弃。</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E8%A7%A3%E9%87%8A%E4%B8%8B%E5%BB%B6%E6%97%B6-x2F-%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97"><span class="toc-number">8.</span> <span class="toc-text">8. 解释下延时&#x2F;延迟队列</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%80%A7"><span class="toc-number">9.</span> <span class="toc-text">9. 如何保证消息的顺序性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-%E5%9B%9B%E7%A7%8D%E4%BA%A4%E6%8D%A2%E6%9C%BA-7%E7%A7%8D%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="toc-number">10.</span> <span class="toc-text">10. 四种交换机+7种工作模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-nginx%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%B0%91"><span class="toc-number">11.</span> <span class="toc-text">11. nginx了解多少</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5"><span class="toc-number">11.1.</span> <span class="toc-text">负载均衡策略</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">12.</span> <span class="toc-text">三次握手</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%882%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8D%E8%A1%8C-%E5%BF%85%E9%A1%BB%E8%A6%813%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">12.0.1.</span> <span class="toc-text">为什么2次握手不行,必须要3次握手</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">12.1.</span> <span class="toc-text">四次挥手</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E7%A7%8Dweb%E9%80%9A%E8%AE%AF%E6%96%B9%E5%BC%8F"><span class="toc-number">13.</span> <span class="toc-text">四种web通讯方式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#UDP%E4%BB%8B%E7%BB%8D"><span class="toc-number">14.</span> <span class="toc-text">UDP介绍</span></a></li></ol>
        </div>
    
</div>


    </div>
</div>
</body>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>






</html>
